Resolve problems with some games: Support other color than 0 for transparency + increase MAX_CONTEXT_SIZE

Signed-off-by: Laurent Merckx <laurent-merckx@skynet.be>

--- a/src/cpu/cpu.h
+++ b/src/cpu/cpu.h
@@ -35,7 +35,7 @@ namespace type
 // 1 meg for I86
 static const int MEM_SIZE =	0x100000;
 /* max # of bytes that a cpu context can have */
-static const int MAX_CONTEXT_SIZE = 100;
+static const int MAX_CONTEXT_SIZE = 128;
 /* how many IRQs we will support per CPU */
 static const int MAX_IRQS = 4;
 
--- a/src/video/palette.cpp
+++ b/src/video/palette.cpp
@@ -71,6 +71,7 @@ bool initialize(unsigned int num_colors)
         for (unsigned int x = 0; x < g_size; x++) {
             // set RGB values to black
             g_rgb[x].r = g_rgb[x].g = g_rgb[x].b = 0;
+            g_rgb[x].a = 0xFF;
 
             g_uRGBAPalette[x] = 0xFF000000; // initialize to opaque black
 
@@ -98,8 +99,10 @@ void set_transparency(unsigned int uColorIndex, bool transparent)
     g_yuv[uColorIndex].transparent = transparent;
 
     if (transparent) {
+        g_rgb[uColorIndex].a = 0x00;
         g_uRGBAPalette[uColorIndex] &= 0x00FFFFFF; // set alpha channel to 0
     } else {
+        g_rgb[uColorIndex].a = 0xFF;
         g_uRGBAPalette[uColorIndex] |= 0xFF000000; // set alpha channel to FF
     }
 }
@@ -117,7 +120,9 @@ void set_color(unsigned int color_num, SDL_Color color_value)
     if ((g_rgb[color_num].r != color_value.r) ||
         (g_rgb[color_num].g != color_value.g) ||
         (g_rgb[color_num].b != color_value.b)) {
-        g_rgb[color_num] = color_value;
+        g_rgb[color_num].r = color_value.r;
+        g_rgb[color_num].g = color_value.g;
+        g_rgb[color_num].b = color_value.b;
         g_modified       = true;
 
         // change R,G,B, values, but don't change A
--- a/src/video/video.cpp
+++ b/src/video/video.cpp
@@ -740,14 +740,11 @@ void vid_update_overlay_surface (SDL_Surface *tx, int x, int y) {
 
     // MAC: 8bpp to RGBA8888 conversion. Black pixels are considered totally transparent so they become 0x00000000;
     for (int i = 0; i < (tx->w * tx->h); i++){
-        if (     *(  ((uint8_t*)tx->pixels)+i ) != 0x00   ) {
 	    *((uint32_t*)(g_screen_blitter->pixels)+i) = //0xff0000ff;
 	    (0x00000000 | tx->format->palette->colors[*((uint8_t*)(tx->pixels)+i)].r) << 24|
 	    (0x00000000 | tx->format->palette->colors[*((uint8_t*)(tx->pixels)+i)].g) << 16|
 	    (0x00000000 | tx->format->palette->colors[*((uint8_t*)(tx->pixels)+i)].b) << 8|
-	    0x000000ff;
-        }
-        else *((uint32_t*)(g_screen_blitter->pixels)+i) = 0x00000000;
+	    (0x00000000 | tx->format->palette->colors[*((uint8_t*)(tx->pixels)+i)].a);
     }
     g_overlay_needs_update = true;
     // MAC: We update the overlay texture later, just when we are going to SDL_RenderCopy() it to the renderer.
