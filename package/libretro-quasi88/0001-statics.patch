--- a/Makefile	2019-07-02 20:39:24.708491968 +0200
+++ b/Makefile	2019-07-02 20:37:31.787461242 +0200
@@ -525,9 +525,9 @@
 FLAGS += $(ENDIANNESS_DEFINES) -DSIZEOF_DOUBLE=8 $(WARNINGS) -DPACKAGE=\"quasi88\" -DPSS_STYLE=1 -DMPC_FIXED_POINT -DSTDC_HEADERS -D__STDC_LIMIT_MACROS -D__LIBRETRO__ -D_LOW_ACCURACY_ $(EXTRA_INCLUDES)
 
 ifneq (,$(findstring msvc,$(platform)))
-FLAGS += -DINLINE="_inline"
+FLAGS += -DINLINE="_inline static"
 else
-FLAGS += -DINLINE="inline"
+FLAGS += -DINLINE="inline static"
 endif
 
 CXXFLAGS += $(FLAGS)
--- a/src/LIBRETRO/libretro-common/include/retro_miscellaneous.h	2019-05-27 06:29:36.000000000 +0200
+++ b/src/LIBRETRO/libretro-common/include/retro_miscellaneous.h	2019-07-02 20:37:17.247328378 +0200
@@ -49,21 +49,21 @@
 #include <compat/msvc.h>
 #endif
 
-static INLINE void bits_or_bits(uint32_t *a, uint32_t *b, uint32_t count)
+INLINE void bits_or_bits(uint32_t *a, uint32_t *b, uint32_t count)
 {
    uint32_t i;
    for (i = 0; i < count;i++)
       a[i] |= b[i];
 }
 
-static INLINE void bits_clear_bits(uint32_t *a, uint32_t *b, uint32_t count)
+INLINE void bits_clear_bits(uint32_t *a, uint32_t *b, uint32_t count)
 {
    uint32_t i;
    for (i = 0; i < count;i++)
       a[i] &= ~b[i];
 }
 
-static INLINE bool bits_any_set(uint32_t* ptr, uint32_t count)
+INLINE bool bits_any_set(uint32_t* ptr, uint32_t count)
 {
    uint32_t i;
    for (i = 0; i < count; i++)
--- a/src/LIBRETRO/libretro-common/include/string/stdstring.h	2019-05-27 06:29:36.000000000 +0200
+++ b/src/LIBRETRO/libretro-common/include/string/stdstring.h	2019-07-02 20:35:23.570288309 +0200
@@ -35,12 +35,12 @@
 
 RETRO_BEGIN_DECLS
 
-static INLINE bool string_is_empty(const char *data)
+INLINE bool string_is_empty(const char *data)
 {
    return (data == NULL) || (*data == '\0');
 }
 
-static INLINE bool string_is_equal(const char *a, const char *b)
+INLINE bool string_is_equal(const char *a, const char *b)
 {
    if (!a || !b)
       return false;
@@ -52,7 +52,7 @@
    return (*(const unsigned char*)a - *(const unsigned char*)b) == 0;
 }
 
-static INLINE bool string_is_not_equal(const char *a, const char *b)
+INLINE bool string_is_not_equal(const char *a, const char *b)
 {
    return !string_is_equal(a, b);
 }
@@ -67,7 +67,7 @@
 #define string_add_glob_open(s, size) strlcat((s), "glob('*",  (size))
 #define string_add_glob_close(s, size) strlcat((s), "*')",  (size))
 
-static INLINE void string_add_between_pairs(char *s, const char *str,
+INLINE void string_add_between_pairs(char *s, const char *str,
       size_t size)
 {
    string_add_pair_open(s, size);
@@ -78,7 +78,7 @@
 #define string_is_not_equal_fast(a, b, size) (memcmp(a, b, size) != 0)
 #define string_is_equal_fast(a, b, size) (memcmp(a, b, size) == 0)
 
-static INLINE bool string_is_equal_case_insensitive(const char *a,
+INLINE bool string_is_equal_case_insensitive(const char *a,
       const char *b)
 {
    int result              = 0;
@@ -97,7 +97,7 @@
    return (result == 0);
 }
 
-static INLINE bool string_is_equal_noncase(const char *a, const char *b)
+INLINE bool string_is_equal_noncase(const char *a, const char *b)
 {
    int result              = 0;
    const unsigned char *p1 = (const unsigned char*)a;
